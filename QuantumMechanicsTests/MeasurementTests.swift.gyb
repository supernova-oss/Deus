%{
  # ===------------------------------------------------------------------------------------------===
  # Copyright Â© 2025 Supernova. All rights reserved.
  #
  # This file is part of the Deus open-source project.
  #
  # This program is free software: you can redistribute it and/or modify it under the terms of the
  # GNU General Public License as published by the Free Software Foundation, either version 3 of the
  # License, or (at your option) any later version.
  #
  # This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
  # without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
  # the GNU General Public License for more details.
  #
  # You should have received a copy of the GNU General Public License along with this program. If
  # not, see https://www.gnu.org/licenses.
  # ===------------------------------------------------------------------------------------------===

  from os import environ
  from reflection import licensing
  from reflection import quantum_mechanics

  all_measurement_types = quantum_mechanics.all_measurement_types()

  def decapitalized(str):
    """Lower-cases the first character of the given string.

    Keyword arguments:
      str -- The string to be decapitalized.
    """

    if not str: return str
    decapitalized = str[0].lower() + str[1:]
    return decapitalized

  def partialize(index, access):
    """Converts a given Swift access from full, prefixed by the name of the enclosing type, into
    partial, in which such prefix is omitted.
    
    These nomenclatures ("full and partial access") do not necessarily reflect that employed by
    Swift in the documentation or the compiler. They are Deus-specific, and compose yet another type
    of access: contextual. An array of contextual accesses contains, in order, a full access
    followed by partial ones.

    Keyword arguments:
      index -- Index of the access in the array.
      access -- The access, in Swift, to a property or function of a type.
    """
    if index == 0 or access.startswith('.'): return access
    return '.' + '.'.join(access.split('.', 1)[1:])
}%
${licensing.header()}

@testable import QuantumMechanics
import Testing

% for measurement_type in all_measurement_types:
  % Self = measurement_type.identifier
  % self = decapitalized(Self)
  % measurables = measurement_type.measurables
  % unit_representable_name = 'UnitRepresentable<' + Self + '>'
  % unit_representables_expression = '[' + ', '.join((('UnitRepresentable(unit: \\' + Self + '.Type.') if index == 0 else '.init(unit: \.') + measurable + ')' for index, measurable in enumerate(measurables)) + ']'
  % full_measurable_accesses = list(map(lambda measurable: Self + '.' + measurable, measurables))
  % contextual_measurable_accesses = [full_measurable_accesses[0]] + list(map(lambda measurable: '.' + measurable, measurables[1:]))
  % measurement_combinations_expression = '[' + ', '.join(', '.join('(' + partialize(value_index, key) + '(2), ' + partialize(key_index, value) + '(2))' for value_index, value in enumerate(contextual_measurable_accesses)) for key_index, key in enumerate(contextual_measurable_accesses)) + ']'
  % measurements_expression = '[' + ', '.join(map(lambda contextual_measurable_access: contextual_measurable_access + '(2)', contextual_measurable_accesses)) + ']'
fileprivate struct ${Self}Tests {
  @Test(arguments: ${unit_representables_expression})
  func makes(in unitRepresentable: ${unit_representable_name}) {
    let measurable = ${Self}.in(unitRepresentable.unit)
    let ${self} = ${Self}._make(quantityInCurrentUnit: 2, conversionCoefficient: measurable.conversionCoefficient, symbol: measurable.symbol)
    #expect(${self}.quantityInCurrentUnit == 2)
    #expect(${self}.conversionCoefficient == measurable.conversionCoefficient)
    #expect(${self}.symbol == measurable.symbol)
  }

  @Test
  func initializesFromBaseUnit() {
    let ${self}: ${Self} = 2
    #expect(${self}.quantityInBaseUnit == 2)
    #expect(${self}.symbol == ${Self}.baseUnitSymbol)
  }

  @Test
  func identityIsZeroInBaseUnit() {
    #expect(${Self}.zero.quantityInCurrentUnit == 0)
    #expect(${Self}.zero.symbol == ${Self}.baseUnitSymbol)
  }

  @Test(arguments: ${unit_representables_expression})
  func negates(in unitRepresentable: ${unit_representable_name}) {
    let initial${Self} = ${Self}.in(unitRepresentable.unit)(2)
    let negated${Self} = -initial${Self}
    #expect(negated${Self} == ${Self}.in(unitRepresentable.unit)(-2))
    #expect(negated${Self}.symbol == initial${Self}.symbol)
  }

  @Test(arguments: ${measurement_combinations_expression})
  func adds(_ addition: ${Self}, to initial: ${Self}) {
    #expect((initial + addition).quantityInBaseUnit.isApproximatelyEqual(to: initial.quantityInBaseUnit + addition.quantityInBaseUnit))
  }

  @Test(arguments: ${measurement_combinations_expression})
  func subtracts(_ subtraction: ${Self}, from initial: ${Self}) {
    #expect((initial - subtraction).quantityInBaseUnit.isApproximatelyEqual(to: initial.quantityInBaseUnit - subtraction.quantityInBaseUnit))
  }

  @Test(arguments: ${unit_representables_expression})
  func isDescribedByQuantityInCurrentUnitAndSymbol(_ unitRepresentable: ${unit_representable_name}) {
    let ${self} = ${Self}.in(unitRepresentable.unit)(2)
    #expect("\(${self})" == "\(${Self}.formatted(quantity: ${self}.quantityInCurrentUnit)) \(${self}.symbol)")
  }

  @Test(arguments: zip(${measurements_expression}, ${unit_representables_expression}))
  func converts(_ initial: ${Self}, into unitRepresentable: ${unit_representable_name}) {
    let converted = initial.converted(into: unitRepresentable.unit)
    #expect(converted.quantityInBaseUnit == initial.quantityInBaseUnit)
    #expect(converted.symbol == ${Self}.in(unitRepresentable.unit).symbol)
  }
}

% end
/// Representation of an SI unit in which a quantity of a ``Measurement`` may be. Exists merely for
/// debugging purposes, allowing for displaying the actual name of the unit while testing rather
/// than the string of the key path.
private struct UnitRepresentable<MeasurementType>: @unchecked Sendable where MeasurementType: Measurement {
  /// The unit of the specified ``Measurement`` being represented.
  let unit: MeasurementType.Unit
}

extension UnitRepresentable: CustomDebugStringConvertible {
  var debugDescription: String {
    switch unit {
% for measurement_type in all_measurement_types:
  % Self = measurement_type.identifier
  % for measurable in measurement_type.measurables:
    case _ where unit == \${Self}.Type.${measurable}: "${measurable}"
  % end
% end
      default: "Unknown instance of UnitRepresentable<\(MeasurementType.self)>"
    }
  }
}
